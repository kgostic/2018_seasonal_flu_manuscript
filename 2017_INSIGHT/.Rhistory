valid1 = subset(splotdat, season == ss & flutype == "1")
valid2 = subset(splotdat, season == ss & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = paste(ss), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
zz = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(zz$x, zz$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
zz = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(zz$x, zz$y, col = 'firebrick')
}
}
## Country-specific plots
ccs = unique(cplotdat$country)
for(cc in ccs){
valid1 = subset(cplotdat, country == cc & flutype == "1")
valid2 = subset(cplotdat, country == cc & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text =paste(cc), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
}
}
dev.off()
}
par(mar = c(1,3,2.5,0))
layout(matrix(c(1,8,2,  8,3,4,  5,6,7), byrow = T, nrow = 3))
par(mfrow = c(4,3))
## Overall
valid1 = subset(dat.002,flutype == "1" & season!='NH.09.10' & season!='SH.10')
valid2 = subset(dat.002,flutype == "2" & season!='NH.09.10' & season!='SH.10')
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'), xpd = NA)
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = 'Overall', side = 3, line = .25, font = 2)
#text(x = 75, y = .08, paste( 'H1N1, n = ', nrow(valid1), '\nH3N2, n = ', nrow(valid2)), cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
## add smoothed density
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
### Plot season-specific
par(mar = c(1.5,3,2,-.5)+1.5)
## Country-specific plots
ssns = unique(splotdat$season)
for(ss in ssns){
valid1 = subset(splotdat, season == ss & flutype == "1")
valid2 = subset(splotdat, season == ss & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = paste(ss), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
zz = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(zz$x, zz$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
zz = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(zz$x, zz$y, col = 'firebrick')
}
}
## Country-specific plots
ccs = unique(cplotdat$country)
valid1
## Plot only countries and subtypes for which at least 50 cases were observed of each subtype
tb = (table(dat.002$country, dat.002$flutype)) # Get counts for each country, H1N1 = 1, H3N2 = 2
include = rownames(tb)[which(tb[,1]>=100 & tb[,2]>=100)]
## Extract data from countries to be included
cplotdat = subset(dat.002, country %in% include)
### Extract data to plot season-specific distributions
## Plot only seasons for which at least 50 cases were observed of each subtype
tb = (table(dat.002$season, dat.002$flutype)) # Get counts for each season, H1N1 = 1, H3N2 = 2
include = rownames(tb)[which(tb[,1]>=100 & tb[,2]>=100)]
## Extract data from countries to be included
splotdat = subset(dat.002, season %in% include)
## Write a function to output transparent colors
## Credit to: http://www.dataanalytics.org.uk/Data%20Analysis/TipsAndTricks/TTR-20150531.htm
tns <- function(colname, percent = 70) {
rgb.val <- col2rgb(colname)
## Make new color using input color as base and alpha set by transparency
tnscol <- rgb(rgb.val[1], rgb.val[2], rgb.val[3], max = 255, alpha = (100-percent)*255/100)
## return
invisible(tnscol)
}
#################################
## Main text INSIGHT plot (Fig. 3)
#################################
{
pdf(outfile1, height = 9)
par(mar = c(1,3,2.5,0))
layout(matrix(c(1,8,2,  8,3,4,  5,6,7), byrow = T, nrow = 3))
par(mfrow = c(4,3))
## Overall
valid1 = subset(dat.002,flutype == "1" & season!='NH.09.10' & season!='SH.10')
valid2 = subset(dat.002,flutype == "2" & season!='NH.09.10' & season!='SH.10')
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'), xpd = NA)
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = 'Overall', side = 3, line = .25, font = 2)
#text(x = 75, y = .08, paste( 'H1N1, n = ', nrow(valid1), '\nH3N2, n = ', nrow(valid2)), cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
## add smoothed density
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
### Plot season-specific
par(mar = c(1.5,3,2,-.5)+1.5)
## Country-specific plots
ssns = unique(splotdat$season)
for(ss in ssns){
valid1 = subset(splotdat, season == ss & flutype == "1")
valid2 = subset(splotdat, season == ss & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = paste(ss), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
zz = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(zz$x, zz$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
zz = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(zz$x, zz$y, col = 'firebrick')
}
}
## Country-specific plots
ccs = unique(cplotdat$country)
for(cc in ccs){
valid1 = subset(cplotdat, country == cc & flutype == "1")
valid2 = subset(cplotdat, country == cc & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text =paste(cc), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
}
}
dev.off()
}
par(mar = c(1,3,2.5,0))
layout(matrix(c(1,8,2,  8,3,4,  5,6,7), byrow = T, nrow = 3))
par(mfrow = c(4,3))
## Overall
valid1 = subset(dat.002,flutype == "1" & season!='NH.09.10' & season!='SH.10')
valid2 = subset(dat.002,flutype == "2" & season!='NH.09.10' & season!='SH.10')
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'), xpd = NA)
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = 'Overall', side = 3, line = .25, font = 2)
#text(x = 75, y = .08, paste( 'H1N1, n = ', nrow(valid1), '\nH3N2, n = ', nrow(valid2)), cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
## add smoothed density
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
### Plot season-specific
par(mar = c(1.5,3,2,-.5)+1.5)
## Country-specific plots
ssns = unique(splotdat$season)
for(ss in ssns){
valid1 = subset(splotdat, season == ss & flutype == "1")
valid2 = subset(splotdat, season == ss & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text = paste(ss), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
zz = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(zz$x, zz$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
zz = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(zz$x, zz$y, col = 'firebrick')
}
}
## Country-specific plots
ccs = unique(cplotdat$country)
for(cc in ccs){
valid1 = subset(cplotdat, country == cc & flutype == "1")
valid2 = subset(cplotdat, country == cc & flutype == "2")
## Plot H1N1 age dist
plot(agerange, age.tab(valid1$age)/nrow(valid1), xlab = '', ylab = '', xlim = c(18, 90), ylim = c(0, .085), main = '', col = tns('dodgerblue'))
mtext(text = 'age', side = 1, line = 1.9, cex = .8)
mtext(text = 'fraction', side = 2, line = 1.9, cex = .8)
mtext(text =paste(cc), side = 3, line = .25, font = 2, cex = .9)
legend('topright', legend = paste(c('H1N1: n = ', 'H3N2: n = '), c(nrow(valid1), nrow(valid2)), sep = ''), col = c('dodgerblue', 'firebrick'), pch = 15, bty = 'n')
if(nrow(valid1) >0){# If cases of this subtype were observed in the country of interest...
## Add smoothing spline
ss = smooth.spline(agerange, age.tab(valid1$age)/nrow(valid1), spar = spar.in)
lines(ss$x, ss$y, col = 'dodgerblue')
}
if(nrow(valid2)>0){
## Plot H3N2 age spline
points(agerange, age.tab(valid2$age)/nrow(valid2), col = tns('firebrick'))
ss = smooth.spline(agerange, age.tab(valid2$age)/nrow(valid2), spar = spar.in)
lines(ss$x, ss$y, col = 'firebrick')
}
}
#### Process likelihood profile outputs form UCLA's Hoffman2 cluster
rm(list = ls())
setwd('~/Dropbox/R/2018_seasonal_flu/2017_INSIGHT/')
load('processed-data/INSIGHT_fitted_models.RData') # Load fitted models
library(ggplot2)
library(reshape)
library(dplyr)
library(tidyr)
# Import a long-form text file of all profiles
long_pro = as.data.frame(read.table('cluster_outputs/INSIGHT_profiles.txt', stringsAsFactors = FALSE))
#long_pro = as.data.frame(read.table('cluster_outputs/test.txt'))
# Add column names
names(long_pro) = c('grid.val', 'prof.nll', 'modname', 'parname', 'date')
long_pro
head(long_pro)
#### OUTPUTS
outfile1 = 'processed-data/INSIGHT_par_ests_CIs.csv'
outfile2 = 'processed-data/INSIGHT_formatted_fits_table.csv'
outfile3 = 'processed-data/AIC_INSIGHT.csv'
write.csv(del.AIC, file = outfile3)
################################
## Use ggplot to plot profiles, as well as best estimates, and check that the profiles intersect MLE estimates
################################
# Create table of par estimates from each model
parmat = matrix(NA, nrow = length(fits), ncol = length(fits$lk.ATUVG$par)+2, dimnames = list(names(fits), c('nll', 'delAIC', names(fits$lk.ATUVG$par))))
parmat[,'nll'] = (sapply(fits, FUN = function(xx) xx$value))
parmat[names(del.AIC),'delAIC'] = del.AIC
for(pp in names(fits$lk.ATUVG$par)){ ## Fill in par estimates
parmat[,pp] = (sapply(fits, FUN = function(xx) xx$par[pp]))
}
parmat
head(parmat)
parmat = as.data.frame(parmat)
parmat$modname = gsub(pattern = 'lk.(\\w+)', replacement = "\\1", rownames(parmat))
## Melt the data frame
long_parmat = melt(as.data.frame(parmat), id.vars = c('nll', 'delAIC', 'modname'))
## remove pars that don't exist in the model of interest
long_parmat = subset(long_parmat, !is.na(value))
head(long_parmat)
# Plot profiles
for(mm in long_parmat$modname){
pp = ggplot()+
geom_point(data = subset(long_pro, modname == mm), aes(x = grid.val, y = prof.nll))+
geom_point(data = subset(long_parmat, modname == mm), aes(x = value, y = nll), color = 'red')+
geom_vline(data = subset(long_parmat, modname == mm), aes(xintercept = value), color = 'red')+
facet_wrap(~parname)
ggsave(filename = paste('scratch-figures/checkINSIGHTprofs_', mm, '.pdf', sep = ""), plot = pp)
}
mm
long_parmat$modname
long_pro
parmat$modname
parmat$modname
mm = 'A'
pp = ggplot()+
geom_point(data = subset(long_pro, modname == mm), aes(x = grid.val, y = prof.nll))+
geom_point(data = subset(long_parmat, modname == mm), aes(x = value, y = nll), color = 'red')+
geom_vline(data = subset(long_parmat, modname == mm), aes(xintercept = value), color = 'red')+
facet_wrap(~parname)
pp
subset(long_pro, modname == mm)
subset(long_parmat, modname == mm)
long_pro$parname
long_parmat$parname
## Melt the data frame
long_parmat = melt(as.data.frame(parmat), id.vars = c('nll', 'delAIC', 'modname'))
## remove pars that don't exist in the model of interest
long_parmat = subset(long_parmat, !is.na(value))
head(long_parmat)
parmat = as.data.frame(parmat)
parmat$modname = gsub(pattern = 'lk.(\\w+)', replacement = "\\1", rownames(parmat))
head(parmat)
## Melt the data frame
long_parmat = melt(as.data.frame(parmat), id.vars = c('nll', 'delAIC', 'modname'), variable_name = 'parname')
head(long_parmat)
pp = ggplot()+
geom_point(data = subset(long_pro, modname == mm), aes(x = grid.val, y = prof.nll))+
geom_point(data = subset(long_parmat, modname == mm), aes(x = value, y = nll), color = 'red')+
geom_vline(data = subset(long_parmat, modname == mm), aes(xintercept = value), color = 'red')+
facet_wrap(~parname)
pp
## Melt the data frame
long_parmat = melt(as.data.frame(parmat), id.vars = c('nll', 'delAIC', 'modname'), variable_name = 'parname')
## remove pars that don't exist in the model of interest
long_parmat = subset(long_parmat, !is.na(value))
pp = ggplot()+
geom_point(data = subset(long_pro, modname == mm), aes(x = grid.val, y = prof.nll))+
geom_point(data = subset(long_parmat, modname == mm), aes(x = value, y = nll), color = 'red')+
geom_vline(data = subset(long_parmat, modname == mm), aes(xintercept = value), color = 'red')+
facet_wrap(~parname)
pp
# Plot profiles
for(mm in parmat$modname){
pp = ggplot()+
geom_point(data = subset(long_pro, modname == mm), aes(x = grid.val, y = prof.nll))+
geom_point(data = subset(long_parmat, modname == mm), aes(x = value, y = nll), color = 'red')+
geom_vline(data = subset(long_parmat, modname == mm), aes(xintercept = value), color = 'red')+
facet_wrap(~parname)
ggsave(filename = paste('scratch-figures/checkINSIGHTprofs_', mm, '.pdf', sep = ""), plot = pp)
}
#These all
################################
## Calculate 95% CIs for all values in profile
################################
## First, make a list of each model and paramter combination for which there should be a profile
modparlist = long_parmat[!is.na(long_parmat$value),]
####################################
## Calculate 95% profile CIs for each model and parameter
####################################
# Define a function to calculate the likelihood ratio threshold, as a function of the best nll value, and the number of constrained pars (df = 1 if only one par is fixed in the profile)
LR.Threshold = function(NLL_best, df){
#-2log(LR) is distributed chi2 with df given by the number of fixed parameters in the profile
#algebraically, the threshold for being in the CI is given by:
threshold = qchisq(.95, df)/2+NLL_best
threshold
}
# Define a function to extract the CI bounds from the grid, and the profile values
LR.CI = function(threshold, nll.vec, pars.vec){
if(any(which(nll.vec > threshold) < which.min(nll.vec))  &  any(which(nll.vec > threshold) > which.min(nll.vec)) ){ #If the minimum is not an end point
#Find string before and after the min value
lower = nll.vec[1:which.min(nll.vec)]
upper = nll.vec[(which.min(nll.vec)-1):length(nll.vec)]
#Extract low CI from first string, and upper CI from upper string
CI = c(pars.vec[which.min(abs(lower-threshold))], pars.vec[length(lower)+which.min(abs(upper-threshold))])
}else{
#If the first value is the minimum
if(any(which(nll.vec > threshold) < which.min(nll.vec)) == FALSE){ CI = c(pars.vec[1], pars.vec[which.min(abs(nll.vec-threshold))]) }
#If the last value is the maximum
if(any(which(nll.vec > threshold) > which.min(nll.vec)) == FALSE){ CI = c(pars.vec[which.min(abs(nll.vec-threshold))], pars.vec[length(nll.vec)])}
}
CI
}
## Extract relevant profile data
LR.CI.wrapper = function(mod.in, par.in){
valid = long_pro[long_pro$modname == mod.in & long_pro$parname == par.in, ]
LR.CI(threshold = LR.Threshold(NLL_best = parmat[paste('lk.', mod.in, sep = ''), 'nll'], df = 1),
nll.vec = valid$prof.nll, pars.vec = valid$grid.val)
}
## Apply the wrapper across each row in the modparlist
CIs=mapply(FUN = LR.CI.wrapper, mod.in = modparlist[,'modname'], par.in = modparlist[,'variable'])
rownames(CIs) = c('low', 'high')
## Extract relevant profile data
LR.CI.wrapper = function(mod.in, par.in){
valid = long_pro[long_pro$modname == mod.in & long_pro$parname == par.in, ]
LR.CI(threshold = LR.Threshold(NLL_best = parmat[paste('lk.', mod.in, sep = ''), 'nll'], df = 1),
nll.vec = valid$prof.nll, pars.vec = valid$grid.val)
}
## Apply the wrapper across each row in the modparlist
CIs=mapply(FUN = LR.CI.wrapper, mod.in = modparlist[,'modname'], par.in = modparlist[,'variable'])
modparlist
## Apply the wrapper across each row in the modparlist
CIs=mapply(FUN = LR.CI.wrapper, mod.in = modparlist[,'modname'], par.in = modparlist[,'parname'])
CIs
rownames(CIs) = c('low', 'high')
## Add to modparlist
modparlist = cbind(modparlist, t(CIs))
## Once import is good, save outputs
write.csv(modparlist, file = outfile1, row.names = FALSE)
## Reformat as a latex table
pasted = paste(sprintf('%.2f', modparlist$value), ' (', sprintf('%.2f', modparlist$low), '-', sprintf('%.2f', modparlist$high), ')', sep = "")
modparlist$pasted = pasted
# Extract variables of interest
longouts = modparlist[,c('modname', 'variable', 'pasted')]
# Extract variables of interest
longouts = modparlist[,c('modname', 'parname', 'pasted')]
# Add del.AIC as a variable
das = data.frame(modname = modparlist$modname, variable = rep('delAIC', nrow(modparlist)), pasted = modparlist$delAIC)
#prune duplicates
das = unique(das)
das$pasted = sprintf('%.02f', das$pasted)
longouts = rbind(longouts, das)
# wide format into a table
outs = spread(data = longouts, variable, pasted)
# wide format into a table
outs = spread(data = longouts, parname, pasted)
# Sort by del.AIC
outs = outs[order(as.numeric(outs$delAIC)), ]
outs = t(outs)
# put modnames and delAIC on top
outs = outs[c(1,17, 2:16), ]
## Write formatted table
write.csv(outs, outfile2, row.names = TRUE)
## Calculate AIC weights using del.AIC
raw.weights = exp(-.5*del.AIC)
AIC.weights = raw.weights/sum(raw.weights)
AIC.weights
imp.type = sub(pattern = "lk.\\w+?([NGS?])", replacement = "\\1", names(AIC.weights))
imp.type[grep('lk.', imp.type)] = 'none'
## Figure out how much weight each type gets
imp.type.weights = sapply(c('N', 'S', 'G', 'none'), FUN = function(tt){
valid = AIC.weights[imp.type == tt]
sum(valid)
})
names(imp.type.weights) = c('NA subtype', 'HA subtype', 'HA group', 'no imprinting')
pie(sort(imp.type.weights), col = c('aquamarine','white', 'gray', 'limegreen'), main = 'Akaike weights')
length(parmat[1,])
paste(parmat[1,], 1:16)
outs
modparlist
## Reformat as a latex table
pasted = paste(sprintf('%.2f', modparlist$value), ' (', sprintf('%.2f', modparlist$low), '-', sprintf('%.2f', modparlist$high), ')', sep = "")
modparlist$pasted = pasted
# Extract variables of interest
longouts = modparlist[,c('modname', 'parname', 'pasted')]
# Add del.AIC as a variable
das = data.frame(modname = modparlist$modname, variable = rep('delAIC', nrow(modparlist)), pasted = modparlist$delAIC)
das
#prune duplicates
das = unique(das)
das$pasted = sprintf('%.02f', das$pasted)
das
longouts
longouts = rbind(longouts, das)
## Reformat as a latex table
pasted = paste(sprintf('%.2f', modparlist$value), ' (', sprintf('%.2f', modparlist$low), '-', sprintf('%.2f', modparlist$high), ')', sep = "")
modparlist$pasted = pasted
# Extract variables of interest
longouts = modparlist[,c('modname', 'parname', 'pasted')]
# Add del.AIC as a variable
das = data.frame(modname = modparlist$modname, variable = rep('delAIC', nrow(modparlist)), pasted = modparlist$delAIC)
#prune duplicates
das = unique(das)
das$pasted = sprintf('%.02f', das$pasted)
longouts = rbind(longouts, das)
longouts
das
head(longouts)
head(das)
# Add del.AIC as a variable
das = data.frame(modname = modparlist$modname, parname = rep('delAIC', nrow(modparlist)), pasted = modparlist$delAIC)
#prune duplicates
das = unique(das)
das$pasted = sprintf('%.02f', das$pasted)
longouts = rbind(longouts, das)
# wide format into a table
outs = spread(data = longouts, parname, pasted)
outs
?spread
# Sort by del.AIC
outs = outs[order(as.numeric(outs$delAIC)), ]
outs = t(outs)
outs
# put modnames and delAIC on top
outs = outs[c(1,17, 2:16), ]
outs
## Write formatted table
write.csv(outs, outfile2, row.names = TRUE)
## Calculate AIC weights using del.AIC
raw.weights = exp(-.5*del.AIC)
AIC.weights = raw.weights/sum(raw.weights)
AIC.weights
imp.type = sub(pattern = "lk.\\w+?([NGS?])", replacement = "\\1", names(AIC.weights))
imp.type[grep('lk.', imp.type)] = 'none'
## Figure out how much weight each type gets
imp.type.weights = sapply(c('N', 'S', 'G', 'none'), FUN = function(tt){
valid = AIC.weights[imp.type == tt]
sum(valid)
})
names(imp.type.weights) = c('NA subtype', 'HA subtype', 'HA group', 'no imprinting')
pie(sort(imp.type.weights), col = c('aquamarine','white', 'gray', 'limegreen'), main = 'Akaike weights')
length(parmat[1,])
paste(parmat[1,], 1:16)
