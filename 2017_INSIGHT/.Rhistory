for(rr in 1:nrow(A.prof)){
plot(grid, A.prof[rr,], xlab = 'value', ylab = 'neg log likelihood', main = rownames(A.prof)[rr])
abline(v = lk.A$par[rr], col = 'red')
}
for(rr in 1:nrow(A.prof)){
plot(grid, A.prof[rr,], xlab = 'value', ylab = 'neg log likelihood', main = rownames(A.prof)[rr])
abline(v = lk.A$par[rr], col = 'red')
points(lk.A$par[rr], lk.A$value, col = 'red')
}
for(rr in 1:nrow(A.prof)){
plot(grid, A.prof[rr,], xlab = 'value', ylab = 'neg log likelihood', main = rownames(A.prof)[rr], ylim = c(lk.A$value-3, lk.A$value+10))
abline(v = lk.A$par[rr], col = 'red')
points(lk.A$par[rr], lk.A$value, col = 'red')
}
for(rr in 1:nrow(A.prof)){
plot(grid, A.prof[rr,], xlab = 'value', ylab = 'neg log likelihood', main = rownames(A.prof)[rr], ylim = c(lk.A$value-3, lk.A$value+50))
abline(v = lk.A$par[rr], col = 'red')
points(lk.A$par[rr], lk.A$value, col = 'red')
}
one_prof_point()
one_prof_point
pro.pars
## Calculate likelihood profiles for all model fits
########################################
# SETUP
########################################
## Clear memory
rm(list = ls())
## Load model fits and source model inputs and likelihood functions
load('processed-data/AZ_model_fits.RData') # Model fits saved as lk.A, lk.AG, lk.AS, lk.AN
source('0func-likelihood.R')
source('00-Inputs_multinomial.R')
## Remove unnecessary vars
rm('bys', 'ii', 'validH1', 'validH3', 'weights')
library('parallel')
## OUTPUTS
outfile1 = 'processed-data/AZ_age_risk_profiles.RData'
########################################
# Write a function wrapper to calculate profiles
########################################
pvec = lk.A$par
lows = rep(.001, length(pvec))
highs = rep(5, length(pvec))
## Write a function wrapper to calculate one profile point value
## Input pvec, a named vector of best paramter estimates from a fitted likelihood. Should include the paramter to be fixed
##       fixpar, name of the parameter to be fixed
##       fixed.par.vale - value of paramter to be fixed
##       lows -  vector of lower par limits, corresponding to each entry in pvec, including the fixed parameter
##       highs - vector of upper par limits
one_prof_point = function(pvec, fixpar, fixed.par.value, lows, highs){
drop = which(names(pvec) == fixpar) # Figure out index of fixed par
# Optimize the likelihood with respect to all free paramters, other than the fixed par
optim(par = pvec[-drop], fn = profile_func, fixed.par.name = fixpar, fixed.par.value = fixed.par.value, wPro.H1 = 1, dat.H1 = H1.master, wPro.H3 = 1, dat.H3 = H3.master, a0.4 = a0.4, a5.10 = a5.10, a11.17 = a11.17, a18.24 = a18.24, a25.31 = a25.31, a32.38 = a32.38, a39.45 = a39.45, a46.52 = a46.52, a53.59 = a53.59, a60.66 = a60.66, a67.73 = a67.73, a74.80 = a74.80, a81.90plus = a81.90plus, method = 'L-BFGS-B', lower = lows[-drop], upper = highs[-drop])$value
}
# ## Test
# one_prof_point(pvec = lk.AG$par, fixpar = 'r5.10', fixed.par.value = .5, lows = rep(.001, length(lk.AG$par)), highs = c(1,1, rep(5, 12)))
#
# one_prof_point(pvec = lk.AG$par, fixpar = 'rPro.H1', fixed.par.value = .5, lows = rep(.001, length(lk.AG$par)), highs = c(1,1, rep(5, 12)))
###### Initialize storage
grid = seq(.005, 2, by = .005) # Define grid of relative risk points to test for each paramter
# Store provile neg log likelihood values in a matrix, with the fixed parameter listed on rows, and grid value listed on columns
A.age.prof = AG.age.prof = AS.age.prof = AN.age.prof = matrix(NA, nrow = 12, ncol = length(grid), dimnames = list(names(lk.A$par), grid))
## Run a profile grid for each age paramter
## Run grids in parallel
cl = makeCluster(detectCores()-1) # Make cluster
clusterExport(cl, ls()) # Export all variables to cluster
age.pars = names(lk.A$par)
## For each age paramter
for(pp in age.pars){
## lk.A age profiles
A.age.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.A$par, fixpar = pp, lows = rep(.001, 12), highs = rep(5, 12))
AG.age.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AG$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
AS.age.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AS$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
AN.age.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AN$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
}
stopCluster(cl)
## Repeat for HA imprinting pars
###### Initialize storage
grid = seq(.005, 1, by = .005) # Define grid of relative risk points to test for each paramter
# Store provile neg log likelihood values in a matrix, with the fixed parameter listed on rows, and grid value listed on columns
AG.imp.prof = AS.imp.prof = AN.imp.prof = matrix(NA, nrow = 2, ncol = length(grid), dimnames = list(c('rPro.H1', 'rPro.H3'), grid))
cl = makeCluster(detectCores()-1) # Make cluster
clusterExport(cl, ls()) # Export all variables to cluster
pro.pars = c('rPro.H1', 'rPro.H3')
## For each age paramter
for(pp in pro.pars){
AG.imp.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AG$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
AS.imp.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AS$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
AN.imp.prof[pp, ] = parSapply(cl = cl, X = grid, FUN = one_prof_point, pvec = lk.AN$par, fixpar = pp, lows = rep(.001, 14), highs = c(1,1, rep(5, 12)))
}
stopCluster(cl)
## Plot results for null model
for(rr in 1:nrow(A.prof)){
plot(grid, A.prof[rr,], xlab = 'value', ylab = 'neg log likelihood', main = rownames(A.prof)[rr], ylim = c(lk.A$value-3, lk.A$value+50))
abline(v = lk.A$par[rr], col = 'red')
points(lk.A$par[rr], lk.A$value, col = 'red')
}
save(A.age.prof, AS.age.prof, AN.age.prof, AG.age.prof, AS.imp.prof, AG.imp.prof, AN.imp.prof, file = outfile1)
# Define a function to calculate the likelihood ratio threshold, as a function of the best nll value, and the number of constrained pars (df = 1 if only one par is fixed in the profile)
LR.Threshold = function(NLL_best, df){
#-2log(LR) is distributed chi2 with df given by the number of fixed parameters in the profile
#algebraically, the threshold for being in the CI is given by:
threshold = qchisq(.95, df)/2+NLL_best
threshold
}
# Define a function to extract the CI bounds from the grid, and the profile values
LR.CI = function(threshold, nll.vec, pars.vec){
if(any(which(nll.vec > threshold) < which.min(nll.vec))  &  any(which(nll.vec > threshold) > which.min(nll.vec)) ){ #If the minimum is not an end point
#Find string before and after the min value
lower = nll.vec[1:which.min(nll.vec)]
upper = nll.vec[(which.min(nll.vec)-1):length(nll.vec)]
#Extract low CI from first string, and upper CI from upper string
CI = c(pars.vec[which.min(abs(lower-threshold))], pars.vec[length(lower)+which.min(abs(upper-threshold))])
}else{
#If the first value is the minimum
if(any(which(nll.vec > threshold) < which.min(nll.vec)) == FALSE){ CI = c(pars.vec[1], pars.vec[which.min(abs(nll.vec-threshold))]) }
#If the last value is the maximum
if(any(which(nll.vec > threshold) > which.min(nll.vec)) == FALSE){ CI = c(pars.vec[which.min(abs(nll.vec-threshold))], pars.vec[length(nll.vec)])}
}
CI
}
## OUTPUTS
outfile1 = 'processed-data/fitted_models.RData'
getwd()
setwd('../2017_INSIGHT/')
#######################################
## Setup and import data
######################################
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R') ## Model inputs
source('0func-multinomial_likelihood.R') ## Likelihood function
## OUTPUTS
outfile1 = 'processed-data/fitted_models.RData'
## Test likelihood optimization
# # Maximal model
## pars.in gives a vector of initial guesses for free paramters. Must be a nmed vector.
## pro.H1 is the master matrix describing probabilities of protection against H1N1. proH1.master describes HA subtye-specific protection, prog1.master describes HA group-specific protection, or proN1.master describes N1-specific protection
## pro.H3 - master protection matrix relevant to H3N2 protection
## lower.in - vector of lower limits for estimated free par values. Order: rAv, rDX, rVS, rpro.H1, rpro.H3
## upper.in - upper limits for estimated free par values
nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, 1, 1, .001, .001, .001, .001), upper = c(3, 3, 10, 10, 1, 1, 1, 1))
## You can exclude factors from the model by excluding their paramter names from the pars.in vector. This signals the wrapper to substitute the null relative risk value (1), which effectively removes the factor from the model.
## Reduced model, vaccination and imprinting only
nll.wrapper(pars.in = c('rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, .001, .001), upper = c(1, 1, 1, 1))
#######################################
## Model comparison
##      null is all cases tested
##      fit to H1N1
######################################
## set upper and lower bounds for all parameter estiamtes
av.low = .001; av.high = 10 # Antiviral treatment could reasonably be associated with increased risk (given that confirmed cases are more likely to be treated), or decreased risk. Allow values above and below 1.
vx.low = .001; vx.high = 1 ## Vaccination should predict decreased risk. Prohibit valeus above 1.
dx.low = .001; dx.high = 10 # Underlying symptoms -- similar to AV treatment
pro.low = 0.001; pro.high = 1 ## Protection should only decrease risk. Prohibit values above 1.
## 1. TUVG
lk.TUVG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVG
## 2. TUVS
lk.TUVS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVS
## 3. TUVN
lk.TUVN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVN
## 4. TUV
lk.TUV = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low, vx.low, vx.low), upper = c(av.high, dx.high, vx.high, vx.high)); lk.TUV
## 5. TUG
lk.TUG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUG
## 6. TUS
lk.TUS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUS
## 7. TUN
lk.TUN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUN
## 8. TU
lk.TU = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low), upper = c(av.high, dx.high)); lk.TU
## 9. TVG
lk.TVG = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVG
## 10. TVS
lk.TVS = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVS
## 11. TVN
lk.TVN = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVN
#######################################
## Setup and import data
######################################
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R') ## Model inputs
source('0func-multinomial_likelihood.R') ## Likelihood function
## OUTPUTS
outfile1 = 'processed-data/fitted_models.RData'
## Test likelihood optimization
# # Maximal model
## pars.in gives a vector of initial guesses for free paramters. Must be a nmed vector.
## pro.H1 is the master matrix describing probabilities of protection against H1N1. proH1.master describes HA subtye-specific protection, prog1.master describes HA group-specific protection, or proN1.master describes N1-specific protection
## pro.H3 - master protection matrix relevant to H3N2 protection
## lower.in - vector of lower limits for estimated free par values. Order: rAv, rDX, rVS, rpro.H1, rpro.H3
## upper.in - upper limits for estimated free par values
nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, 1, 1, .001, .001, .001, .001), upper = c(3, 3, 10, 10, 1, 1, 1, 1))
## Write a function wrapper, so that you can optimize the likelihood, but only have to input a vector of initial par values and par value limits involved in model comparison
nll.wrapper = function(pars.in, pro.H1, pro.H3, lower.in, upper.in){
## Concatenate vector to initialize pars that may or may not be included, with a vector of all age pars (always included)
pvec = c(pars.in, r18.24 = .9, r25.31 = .9, r39.45 = .9, r46.52 = .9, r53.59 = .9, r60.66 =.9, r67.73= .9, r74.80 = .9, r81.90 = .9)
optim(par = pvec, fn = nll, wAV = av.master, wDX = dx.master, wVX = vac.master, wPro.H1 = pro.H1, wPro.H3 = pro.H3, a18.24 = a18.24, a25.31 = a25.31, a32.38 = a32.38, a39.45 = a39.45, a46.52 = a46.52, a53.59 = a53.59, a60.66 = a60.66, a67.73 = a67.73, a74.80 = a74.80, a81.90 = a81.90, dat.H1 = H1.master, dat.H3 = H3.master, tested.master = tested.master/rowSums(tested.master), method = 'L-BFGS-B', lower = c(lower.in, rep(.001, 9)), upper = c(upper.in, rep(5, 9)))
}
source('~/Dropbox/R/2018_seasonal_flu/2017_INSIGHT/0func-multinomial_likelihood.R', echo=TRUE)
source('~/Dropbox/R/2018_seasonal_flu/2017_INSIGHT/0func-multinomial_likelihood.R', echo=TRUE)
source('~/Dropbox/R/2018_seasonal_flu/2017_INSIGHT/0func-multinomial_likelihood.R', echo=TRUE)
#######################################
## Setup and import data
######################################
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R') ## Model inputs
source('0func-multinomial_likelihood.R') ## Likelihood function
## OUTPUTS
outfile1 = 'processed-data/fitted_models.RData'
## Test likelihood optimization
# # Maximal model
## pars.in gives a vector of initial guesses for free paramters. Must be a nmed vector.
## pro.H1 is the master matrix describing probabilities of protection against H1N1. proH1.master describes HA subtye-specific protection, prog1.master describes HA group-specific protection, or proN1.master describes N1-specific protection
## pro.H3 - master protection matrix relevant to H3N2 protection
## lower.in - vector of lower limits for estimated free par values. Order: rAv, rDX, rVS, rpro.H1, rpro.H3
## upper.in - upper limits for estimated free par values
nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, 1, 1, .001, .001, .001, .001), upper = c(3, 3, 10, 10, 1, 1, 1, 1))
## You can exclude factors from the model by excluding their paramter names from the pars.in vector. This signals the wrapper to substitute the null relative risk value (1), which effectively removes the factor from the model.
## Reduced model, vaccination and imprinting only
nll.wrapper(pars.in = c('rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, .001, .001), upper = c(1, 1, 1, 1))
#######################################
## Model comparison
##      null is all cases tested
##      fit to H1N1
######################################
## set upper and lower bounds for all parameter estiamtes
av.low = .001; av.high = 10 # Antiviral treatment could reasonably be associated with increased risk (given that confirmed cases are more likely to be treated), or decreased risk. Allow values above and below 1.
vx.low = .001; vx.high = 1 ## Vaccination should predict decreased risk. Prohibit valeus above 1.
dx.low = .001; dx.high = 10 # Underlying symptoms -- similar to AV treatment
pro.low = 0.001; pro.high = 1 ## Protection should only decrease risk. Prohibit values above 1.
## 1. TUVG
lk.TUVG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVG
## 2. TUVS
lk.TUVS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVS
## 3. TUVN
lk.TUVN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.TUVN
## 4. TUV
lk.TUV = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low, vx.low, vx.low), upper = c(av.high, dx.high, vx.high, vx.high)); lk.TUV
## 5. TUG
lk.TUG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUG
## 6. TUS
lk.TUS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUS
## 7. TUN
lk.TUN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.TUN
## 8. TU
lk.TU = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low), upper = c(av.high, dx.high)); lk.TU
## 9. TVG
lk.TVG = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVG
## 10. TVS
lk.TVS = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVS
## 11. TVN
lk.TVN = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.TVN
## 12. TV
lk.TV = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, vx.low, vx.low), upper = c(av.high, vx.high, vx.high)); lk.TV
## 13. UVG
lk.UVG = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.UVG
## 14. UVS
lk.UVS = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.UVS
## 15. UVN
lk.UVN = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.UVN
## 16. UV
lk.UV = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(dx.low, vx.low, vx.low), upper = c(dx.high, vx.high, vx.high)); lk.UV
## 17. UG
lk.UG = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.UG
## 18. US
lk.US = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.US
## 19. UN
lk.UN = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.UN
## 20. U
lk.U = nll.wrapper(pars.in = c('rDX' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(dx.low), upper = c(dx.high)); lk.U
## 21. TG
lk.TG = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.TG
## 22. TS
lk.TS = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.TS
## 23. TN
lk.TN = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.TN
## 24. T
lk.T = nll.wrapper(pars.in = c('rAV' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low), upper = c(av.high)); lk.T
## 25. VG
lk.VG = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.VG
## 26. VS
lk.VS = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.VS
## 27. VN
lk.VN = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.VN
## 28. V
lk.V = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(vx.low, vx.low), upper = c(vx.high, vx.high)); lk.V
## 29. G
lk.G = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.G
## 30. S
lk.S = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.S
## 31. N
lk.N = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.N
## 32. NULL
lk.null = nll.wrapper(pars.in = NULL, pro.H1 = 1, pro.H3 = 1, lower.in = NULL, upper = NULL); lk.null
## Pull out the variable names that store likelihoods
mods = mget(ls(pattern = "lk."))
nlls = numeric(length(mods))
AICs = numeric(length(mods))
for(ii in 1:length(mods)){
nlls[ii] = mods[[ii]]$value
AICs[ii] = 2*length(mods[[ii]]$par)+2*mods[[ii]]$value
}
names(AICs) = names(mods)
names(nlls) = names(mods)
AICs = sort(AICs)
del.AIC = AICs - min(AICs)
del.AIC.full = del.AIC
del.AIC
## Plot AIC results
mods = mods[rev(names(del.AIC.full))]
factors = c('T', 'U', 'V', 'S', 'G', 'N')
T.valid = grep('T', names(mods))
#####################
## save fitted models
#####################
save(mget(ls(pattern = 'lk.\\w+')), del.AIC, file = outfile1)
(mget(ls(pattern = 'lk.\\w+'))
)
mget(ls(pattern = 'lk.\\w+'))
#####################
## save fitted models
#####################
save(mget(ls(pattern = 'lk.\\w+')), del.AIC, file = outfile1)
#####################
## save fitted models
#####################
fits = mget(ls(pattern = 'lk.\\w+'))
ls(fits)
save(fits, del.AIC, file = outfile1)
rm(list = ls())
souce('00-Import_FLU002_-for-multinomial.R')
source('0func-multinomial_likelihood.R')
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R')
source('0func-multinomial_likelihood.R')
load('processed-data/fitted_models.RData')
#############################
## Write a function wrapper to calculate likelihood profiles
############################
pvec = lk.A$par
ls()
attach(fits)
ls()
lk.G
## Model comparison for INSIGHT FLU002
##  Fit multinomial models containing all possible combinations of imprinting hypotheses and medical history
##  Use AIC to compare model fits
#######################################
## Setup and import data
######################################
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R') ## Model inputs
source('0func-multinomial_likelihood.R') ## Likelihood function
## OUTPUTS
outfile1 = 'processed-data/fitted_models.RData'
## Test likelihood optimization
# # Maximal model
## pars.in gives a vector of initial guesses for free paramters. Must be a nmed vector.
## pro.H1 is the master matrix describing probabilities of protection against H1N1. proH1.master describes HA subtye-specific protection, prog1.master describes HA group-specific protection, or proN1.master describes N1-specific protection
## pro.H3 - master protection matrix relevant to H3N2 protection
## lower.in - vector of lower limits for estimated free par values. Order: rAv, rDX, rVS, rpro.H1, rpro.H3
## upper.in - upper limits for estimated free par values
nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, 1, 1, .001, .001, .001, .001), upper = c(3, 3, 10, 10, 1, 1, 1, 1))
## You can exclude factors from the model by excluding their paramter names from the pars.in vector. This signals the wrapper to substitute the null relative risk value (1), which effectively removes the factor from the model.
## Reduced model, vaccination and imprinting only
nll.wrapper(pars.in = c('rVX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(.001, .001, .001, .001), upper = c(1, 1, 1, 1))
#######################################
## Model comparison
##      null is all cases tested
##      fit to H1N1
######################################
## set upper and lower bounds for all parameter estiamtes
av.low = .001; av.high = 10 # Antiviral treatment could reasonably be associated with increased risk (given that confirmed cases are more likely to be treated), or decreased risk. Allow values above and below 1.
vx.low = .001; vx.high = 1 ## Vaccination should predict decreased risk. Prohibit valeus above 1.
dx.low = .001; dx.high = 10 # Underlying symptoms -- similar to AV treatment
pro.low = 0.001; pro.high = 1 ## Protection should only decrease risk. Prohibit values above 1.
## All models contain age, so A abbreviation omitted.
# T = antivirals
# U = underlying symptoms
# V = vaccination
# G = group
# S = subtype
# N = neuraminidase
## 1. TUVG
lk.ATUVG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.ATUVG
## 2. TUVS
lk.ATUVS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.ATUVS
## 3. TUVN
lk.ATUVN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, dx.high, vx.high, vx.high, pro.high, pro.high)); lk.ATUVN
## 4. TUV
lk.ATUV = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low, vx.low, vx.low), upper = c(av.high, dx.high, vx.high, vx.high)); lk.ATUV
## 5. TUG
lk.ATUG = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.ATUG
## 6. TUS
lk.ATUS = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.ATUS
## 7. TUN
lk.ATUN = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, dx.low, pro.low, pro.low), upper = c(av.high, dx.high, pro.high, pro.high)); lk.ATUN
## 8. TU
lk.ATU = nll.wrapper(pars.in = c('rAV' = .5, 'rDX' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, dx.low), upper = c(av.high, dx.high)); lk.ATU
## 9. TVG
lk.ATVG = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.ATVG
## 10. TVS
lk.ATVS = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.ATVS
## 11. TVN
lk.ATVN = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, vx.low, vx.low, pro.low, pro.low), upper = c(av.high, vx.high, vx.high, pro.high, pro.high)); lk.ATVN
## 12. TV
lk.ATV = nll.wrapper(pars.in = c('rAV' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low, vx.low, vx.low), upper = c(av.high, vx.high, vx.high)); lk.ATV
## 13. UVG
lk.AUVG = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.AUVG
## 14. UVS
lk.AUVS = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.AUVS
## 15. UVN
lk.AUVN = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(dx.low, vx.low, vx.low, pro.low, pro.low), upper = c(dx.high, vx.high, vx.high, pro.high, pro.high)); lk.AUVN
## 16. UV
lk.AUV = nll.wrapper(pars.in = c('rDX' = .5, 'rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(dx.low, vx.low, vx.low), upper = c(dx.high, vx.high, vx.high)); lk.AUV
## 17. UG
lk.AUG = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.AUG
## 18. US
lk.AUS = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.AUS
## 19. UN
lk.AUN = nll.wrapper(pars.in = c('rDX' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(dx.low, pro.low, pro.low), upper = c(dx.high, pro.high, pro.high)); lk.AUN
## 20. U
lk.AU = nll.wrapper(pars.in = c('rDX' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(dx.low), upper = c(dx.high)); lk.AU
## 21. TG
lk.ATG = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.ATG
## 22. TS
lk.ATS = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.ATS
## 23. TN
lk.ATN = nll.wrapper(pars.in = c('rAV' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(av.low, pro.low, pro.low), upper = c(av.high, pro.high, pro.high)); lk.ATN
## 24. T
lk.AT = nll.wrapper(pars.in = c('rAV' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(av.low), upper = c(av.high)); lk.AT
## 25. VG
lk.AVG = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.AVG
## 26. VS
lk.AVS = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.AVS
## 27. VN
lk.AVN = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5, 'rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(vx.low, vx.low, pro.low, pro.low), upper = c(vx.high, vx.high, pro.high, pro.high)); lk.AVN
## 28. V
lk.AV = nll.wrapper(pars.in = c('rVX.H1' = .5, 'rVX.H3' = .5), pro.H1 = 1, pro.H3 = 1, lower.in = c(vx.low, vx.low), upper = c(vx.high, vx.high)); lk.AV
## 29. G
lk.AG = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = prog1.master, pro.H3 = prog2.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.AG
## 30. S
lk.AS = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proH1.master, pro.H3 = proH3.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.AS
## 31. N
lk.AN = nll.wrapper(pars.in = c('rPro.H1' = .5, 'rPro.H3' = .5), pro.H1 = proN1.master, pro.H3 = proN2.master, lower.in = c(pro.low, pro.low), upper = c(pro.high, pro.high)); lk.AN
## 32. NULL
lk.A = nll.wrapper(pars.in = NULL, pro.H1 = 1, pro.H3 = 1, lower.in = NULL, upper = NULL); lk.A
## Pull out the variable names that store likelihoods
mods = mget(ls(pattern = "lk."))
nlls = numeric(length(mods))
AICs = numeric(length(mods))
for(ii in 1:length(mods)){
nlls[ii] = mods[[ii]]$value
AICs[ii] = 2*length(mods[[ii]]$par)+2*mods[[ii]]$value
}
names(AICs) = names(mods)
names(nlls) = names(mods)
AICs = sort(AICs)
del.AIC = AICs - min(AICs)
del.AIC.full = del.AIC
del.AIC
# T = antivirals
# U = underlying symptoms
# V = vaccination
# G = group
# S = subtype
# N = neuraminidase
#####################
## save fitted models
#####################
fits = mget(ls(pattern = 'lk.\\w+'))
save(fits, del.AIC, file = outfile1)
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R')
source('0func-multinomial_likelihood.R')
load('processed-data/fitted_models.RData')
attach(fits)
#############################
## Write a function wrapper to calculate likelihood profiles
############################
pvec = lk.A$par
lows = rep(.001, length(pvec))
highs = rep(5, length(pvec))
lk.A$par
fixpar = 'r18.24'
fixed.par.value = .5
drop = which(names(pvec) == fixpar) # Figure out index of fixed par
pvec[-drop]
all free paramters, other than the fixed par
optim(par = pvec[-drop], fn =
profile_func
)
profile_func
profile_function()
## Calculate likelihood profiles for all paramters in models fitted to INSIGHT data
rm(list = ls())
source('00-Import_FLU002_-for-multinomial.R')
source('0func-multinomial_likelihood.R')
load('processed-data/fitted_models.RData')
attach(fits)
#############################
## Write a function wrapper to calculate likelihood profiles
############################
pvec = lk.A$par
lows = rep(.001, length(pvec))
highs = rep(5, length(pvec))
#############################
## Write a function wrapper to calculate likelihood profiles
############################
pvec = lk.A$par
lows = rep(.001, length(pvec))
highs = rep(5, length(pvec))
